<h2 cid="n0" mdtype="heading" contenteditable="true" class="md-end-block md-heading"><span md-inline="plain" class="md-plain">前言</span></h2><p cid="n2" mdtype="paragraph" contenteditable="true" class="md-end-block md-p md-focus"><span md-inline="plain" class="md-plain md-expand">大家好我是搬砖小胡，初次发布文章总结，说的不太对的地方还请网友们多多包涵。发布文章主要也是巩固自己的知识更加熟练，全凭自己的理解和网上查资料总结出来的，如有不对的地方还望多多指点。下面是我总结的一下常见面试题，为了督促自己还可以会继续更新😀</span></p><h2 cid="n3" mdtype="heading" contenteditable="true" class="md-end-block md-heading"><span md-inline="plain" class="md-plain">js部分</span></h2><h3 cid="n4" mdtype="heading" contenteditable="true" class="md-end-block md-heading"><span md-inline="plain" class="md-plain">1.谈一谈你对原型链的理解</span></h3><p cid="n5" mdtype="paragraph" contenteditable="true" class="md-end-block md-p"><span md-inline="plain" class="md-plain">在js语言中，每个实例对象都有一个</span><span md-inline="code" spellcheck="false" class="md-pair-s"><span class="md-meta md-before">`</span><code>__proto__</code><span class="md-meta md-after">`</span></span><span md-inline="plain" class="md-plain">属性，改属性指向他的原型对象，且这个实例对象的构造函数都有一个原型属性</span><span md-inline="code" spellcheck="false" class="md-pair-s"><span class="md-meta md-before">`</span><code>prototype</code><span class="md-meta md-after">`</span></span><span md-inline="plain" class="md-plain">,与实例对象的</span><span md-inline="strong" class="md-pair-s "><span class="md-meta md-before">__</span><strong><span md-inline="plain" class="md-plain">proto</span></strong><span class="md-meta md-after">__</span></span><span md-inline="plain" class="md-plain">属性指向同一个对象，当这个对象在查找一个属性的值时，自身没有就会根据</span><span md-inline="strong" class="md-pair-s "><span class="md-meta md-before">__</span><strong><span md-inline="plain" class="md-plain">proto</span></strong><span class="md-meta md-after">__</span></span><span md-inline="plain" class="md-plain">向他的</span><span md-inline="code" spellcheck="false" class="md-pair-s"><span class="md-meta md-before">`</span><code>原型</code><span class="md-meta md-after">`</span></span><span md-inline="plain" class="md-plain">上寻找，如果不存在，则会到生成这个实例对象的构造函数的原型对象上寻找，如果还是不存在，就继续道Object的原型对象上找，在往上找就为null了，这个链式寻找的过程，就被称为</span><span md-inline="code" spellcheck="false" class="md-pair-s"><span class="md-meta md-before">`</span><code>原型链</code><span class="md-meta md-after">`</span></span><span md-inline="plain" class="md-plain">。</span></p><h3 cid="n6" mdtype="heading" contenteditable="true" class="md-end-block md-heading"><span md-inline="plain" class="md-plain">2. 原型、构造函数、实例对象三者的关系</span></h3><p cid="n7" mdtype="paragraph" contenteditable="true" class="md-end-block md-p"><span md-inline="plain" class="md-plain">首先从构造函数说起，构造函数通过</span><span md-inline="code" spellcheck="false" class="md-pair-s"><span class="md-meta md-before">`</span><code>prototype</code><span class="md-meta md-after">`</span></span><span md-inline="plain" class="md-plain">指向他的原型对象，原型对象通过他的</span><span md-inline="code" spellcheck="false" class="md-pair-s"><span class="md-meta md-before">`</span><code>constructor</code><span class="md-meta md-after">`</span></span><span md-inline="plain" class="md-plain">属性指回这个构造函数，表明原型对象是由哪个构造函数生成的。原型对象通过new关键字生成的实例对象，这个实例对象可以通过</span><span md-inline="code" spellcheck="false" class="md-pair-s"><span class="md-meta md-before">`</span><code>__proto__</code><span class="md-meta md-after">`</span></span><span md-inline="plain" class="md-plain">属性指向生成这个实例对象的构造函数的原型对象，实现一个三角关系。</span></p><p cid="n8" mdtype="paragraph" contenteditable="true" class="md-end-block md-p"><span md-inline="image" data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ef12cf395738424f98314491f8e4d934~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?" contenteditable="false" class="md-image md-img-loaded"><span class="md-meta md-before md-content" contenteditable="true"><span class="md-image-before-src ty-focusable">![2.jpg](</span><span class="md-image-src-span ty-focusable">https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ef12cf395738424f98314491f8e4d934~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?</span><span class="md-image-after-src">)</span></span><img referrerpolicy="no-referrer" alt="2.jpg" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ef12cf395738424f98314491f8e4d934~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?" onerror="onImageErrorFunc(event)" onload="onLoadedFuncForQuickAction(event)"></span></p><h3 cid="n9" mdtype="heading" contenteditable="true" class="md-end-block md-heading"><span md-inline="plain" class="md-plain">3.实现继承的方式</span></h3><p cid="n10" mdtype="paragraph" contenteditable="true" class="md-end-block md-p"><span md-inline="plain" class="md-plain">继承的方式有很多种，网上的答案都有很多，我自己总结且大致说的明白的有这五种</span><span md-inline="softbreak" class="md-softbreak">
</span><span md-inline="plain" class="md-plain"> </span><span md-inline="strong" class="md-pair-s "><span class="md-meta md-before">**</span><strong><span md-inline="plain" class="md-plain">1.原型链继承</span></strong><span class="md-meta md-after">**</span></span><span md-inline="plain" class="md-plain"> 借助原型可以基于已有的对象创建对象，同时还不必因此创建自定义类型。 在 object()函数内部，先创建一个临时的构造函数，然后将传入的对象作为这个构造 函数的原型，最后返回了这个临时类型的一个新实例。关键代码：</span><span md-inline="code" spellcheck="false" class="md-pair-s"><span class="md-meta md-before">`</span><code>Star.proyotype = new Person(), Star.proyotype.constructor = Star</code><span class="md-meta md-after">`</span></span><span md-inline="plain" class="md-plain"> 缺点：只能继承父类的方法</span><span md-inline="softbreak" class="md-softbreak">
</span><span md-inline="plain" class="md-plain"> </span><span md-inline="strong" class="md-pair-s "><span class="md-meta md-before">**</span><strong><span md-inline="plain" class="md-plain">2.借用构造函数继承</span></strong><span class="md-meta md-after">**</span></span><span md-inline="softbreak" class="md-softbreak">
</span><span md-inline="plain" class="md-plain"> 在子类构造函数的内部调用超类型构造函数。可以通过使用 </span><span md-inline="code" spellcheck="false" class="md-pair-s"><span class="md-meta md-before">`</span><code>apply()</code><span class="md-meta md-after">`</span></span><span md-inline="plain" class="md-plain">和 </span><span md-inline="code" spellcheck="false" class="md-pair-s"><span class="md-meta md-before">`</span><code>call()</code><span class="md-meta md-after">`</span></span><span md-inline="plain" class="md-plain">方 法在新创建的对象上执行构造函数。关键代码：</span><span md-inline="code" spellcheck="false" class="md-pair-s"><span class="md-meta md-before">`</span><code>Person.call(this,age,name)</code><span class="md-meta md-after">`</span></span><span md-inline="plain" class="md-plain"> 缺点：无法复用，只能继承父类的属性</span><span md-inline="softbreak" class="md-softbreak">
</span><span md-inline="plain" class="md-plain"> </span><span md-inline="strong" class="md-pair-s "><span class="md-meta md-before">**</span><strong><span md-inline="plain" class="md-plain">3.组合继承</span></strong><span class="md-meta md-after">**</span></span><span md-inline="softbreak" class="md-softbreak">
</span><span md-inline="plain" class="md-plain"> 也叫伪经典继承。指的是将原型链和借用构造函数的技术组合到一 起，从而发挥二者之长。使用原型链实现对原型属性属性和方法的继承，通过借用构造函数来实现实例 属性的继承。 既通过在原型上定义方法实现了函数复用，又能保证每一个实例都有它自己的属性。但是会有一个小bug，里面的age，name，有两份，有一份的值为undefined，因为里面的</span><span md-inline="code" spellcheck="false" class="md-pair-s"><span class="md-meta md-before">`</span><code>apply()</code><span class="md-meta md-after">`</span></span><span md-inline="plain" class="md-plain">和</span><span md-inline="code" spellcheck="false" class="md-pair-s"><span class="md-meta md-before">`</span><code>call()</code><span class="md-meta md-after">`</span></span><span md-inline="plain" class="md-plain">方法会自动多调用一次。</span><span md-inline="softbreak" class="md-softbreak">
</span><span md-inline="plain" class="md-plain"> </span><span md-inline="strong" class="md-pair-s "><span class="md-meta md-before">**</span><strong><span md-inline="plain" class="md-plain">4.寄生组合继承</span></strong><span class="md-meta md-after">**</span></span><span md-inline="softbreak" class="md-softbreak">
</span><span md-inline="plain" class="md-plain"> 通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。 本质上，就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。是公认继承比较全面的一种方法，要写全的话还是非常多的，我只会一个简单的🤣，关键代码：</span><span md-inline="code" spellcheck="false" class="md-pair-s"><span class="md-meta md-before">`</span><code>Star.prototype = Object.create(Person.prototype)</code><span class="md-meta md-after">`</span></span><span md-inline="softbreak" class="md-softbreak">
</span><span md-inline="plain" class="md-plain"> </span><span md-inline="strong" class="md-pair-s "><span class="md-meta md-before">**</span><strong><span md-inline="plain" class="md-plain">5.ES6的Class类继承方式</span></strong><span class="md-meta md-after">**</span></span><span md-inline="softbreak" class="md-softbreak">
</span><span md-inline="plain" class="md-plain"> 可利用class关键字配合extends关键字来实现继承。ES6中引入了class关键字来声明类，而class（类）可通过</span><span md-inline="code" spellcheck="false" class="md-pair-s"><span class="md-meta md-before">`</span><code>extends</code><span class="md-meta md-after">`</span></span><span md-inline="plain" class="md-plain">来继承父类中属性和方法，</span><span md-inline="code" spellcheck="false" class="md-pair-s"><span class="md-meta md-before">`</span><code>super</code><span class="md-meta md-after">`</span></span><span md-inline="plain" class="md-plain">指向父类的原型对象，可以调用父类的属性和方法，且子类constructor方法中必须有super关键字，且必须出现在this之前。</span></p><h3 cid="n11" mdtype="heading" contenteditable="true" class="md-end-block md-heading"><span md-inline="plain" class="md-plain">4.js数据类型</span></h3><p cid="n12" mdtype="paragraph" contenteditable="true" class="md-end-block md-p"><span md-inline="strong" class="md-pair-s "><span class="md-meta md-before">**</span><strong><span md-inline="plain" class="md-plain">数据类型从大的方向来说分为两种</span></strong><span class="md-meta md-after">**</span></span></p><ul class="ul-list" cid="n13" mdtype="list" data-mark="-"><li class="md-list-item" cid="n14" mdtype="list_item"><p cid="n15" mdtype="paragraph" contenteditable="true" class="md-end-block md-p"><span md-inline="plain" class="md-plain">基本数据类型：字符串(String)，数字(Number)，布尔(Boolean)，空(Null)，未定义(Undefined)，Symbol(nbs)</span></p></li><li class="md-list-item" cid="n16" mdtype="list_item"><p cid="n17" mdtype="paragraph" contenteditable="true" class="md-end-block md-p"><span md-inline="plain" class="md-plain">复杂数据类型：对象(Object)，数组(Array)，函数(Function)</span><span md-inline="softbreak" class="md-softbreak">
</span><span md-inline="plain" class="md-plain">Symbol表示独一无二的值，避免属性名的冲突</span></p></li></ul><h3 cid="n18" mdtype="heading" contenteditable="true" class="md-end-block md-heading"><span md-inline="plain" class="md-plain">5.检测数据类型</span></h3><ol class="ol-list" start="" cid="n19" mdtype="list"><li class="md-list-item" cid="n20" mdtype="list_item"><p cid="n21" mdtype="paragraph" contenteditable="true" class="md-end-block md-p"><span md-inline="code" spellcheck="false" class="md-pair-s"><span class="md-meta md-before">`</span><code>typeof</code><span class="md-meta md-after">`</span></span><span md-inline="plain" class="md-plain"> 检测 存在的问题:null 或者数组打印出来也是 object</span></p></li><li class="md-list-item" cid="n22" mdtype="list_item"><p cid="n23" mdtype="paragraph" contenteditable="true" class="md-end-block md-p"><span md-inline="code" spellcheck="false" class="md-pair-s"><span class="md-meta md-before">`</span><code>instanceof</code><span class="md-meta md-after">`</span></span><span md-inline="plain" class="md-plain"> (只能检测复杂数据类型)</span><span md-inline="softbreak" class="md-softbreak">
</span><span md-inline="plain" class="md-plain">返回值是 true 或者 false 相关的构造函数只要在原型链上,就是 true,否则就是 false 可以用于检测是不是数组</span></p></li><li class="md-list-item" cid="n24" mdtype="list_item"><p cid="n25" mdtype="paragraph" contenteditable="true" class="md-end-block md-p"><span md-inline="code" spellcheck="false" class="md-pair-s"><span class="md-meta md-before">`</span><code>Object.prototype.toString.call</code><span class="md-meta md-after">`</span></span><span md-inline="plain" class="md-plain">(要检测的数据值)</span><span md-inline="softbreak" class="md-softbreak">
</span><span md-inline="plain" class="md-plain">为什么要借 Object.prototype.toString,因为自己的 toString 被自己原型重写了,得不到类似[object Object]</span></p></li></ol><h4 cid="n26" mdtype="heading" contenteditable="true" class="md-end-block md-heading"><span md-inline="plain" class="md-plain">6.如何检测一个数据是数组</span></h4><pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="false" lang="js" cid="n27" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="js"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 9.52344px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; min-height: 115px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor" style="left: 4px; top: 0px; height: 23.0469px;">&nbsp;</div></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">var</span> <span class="cm-def">arr</span> <span class="cm-operator">=</span> [<span class="cm-number">2</span>, <span class="cm-number">3</span>, <span class="cm-number">4</span>]</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">arr</span> <span class="cm-keyword">instanceof</span> <span class="cm-variable">Array</span>)</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">Array</span>.<span class="cm-property">isArray</span>(<span class="cm-variable">arr</span>))</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">Object</span>.<span class="cm-property">prototype</span>.<span class="cm-property">toString</span>.<span class="cm-property">call</span>(<span class="cm-variable">arr</span>))</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">复制代码</span></span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 115px;"></div><div class="CodeMirror-gutters" style="display: none; height: 115px;"></div></div></div></pre><h3 cid="n28" mdtype="heading" contenteditable="true" class="md-end-block md-heading"><span md-inline="plain" class="md-plain">7.深拷贝和浅拷贝</span></h3><ul class="ul-list" cid="n29" mdtype="list" data-mark="-"><li class="md-list-item" cid="n30" mdtype="list_item"><p cid="n31" mdtype="paragraph" contenteditable="true" class="md-end-block md-p"><span md-inline="plain" class="md-plain">浅拷贝：只是拷贝一层，更深层次对象级别的只拷贝了地址</span></p></li><li class="md-list-item" cid="n32" mdtype="list_item"><p cid="n33" mdtype="paragraph" contenteditable="true" class="md-end-block md-p"><span md-inline="plain" class="md-plain">深拷贝：层层拷贝，每一级别的数据都会拷贝</span></p></li><li class="md-list-item" cid="n34" mdtype="list_item"><p cid="n35" mdtype="paragraph" contenteditable="true" class="md-end-block md-p"><span md-inline="plain" class="md-plain">浅拷贝方法：</span><span md-inline="softbreak" class="md-softbreak">
</span><span md-inline="plain" class="md-plain">\1. 使用 lodash 浅拷贝 </span><span md-inline="code" spellcheck="false" class="md-pair-s"><span class="md-meta md-before">`</span><code>clone</code><span class="md-meta md-after">`</span></span><span md-inline="plain" class="md-plain"> 方法，让他们俩指向不同地址</span><span md-inline="softbreak" class="md-softbreak">
</span><span md-inline="plain" class="md-plain">\2. 使用 </span><span md-inline="code" spellcheck="false" class="md-pair-s"><span class="md-meta md-before">`</span><code>Object.assign</code><span class="md-meta md-after">`</span></span><span md-inline="plain" class="md-plain"> 方法</span><span md-inline="softbreak" class="md-softbreak">
</span><span md-inline="plain" class="md-plain">\3. 使用es6语法的 </span><span md-inline="code" spellcheck="false" class="md-pair-s"><span class="md-meta md-before">`</span><code>...</code><span class="md-meta md-after">`</span></span><span md-inline="plain" class="md-plain"> 拓展运算符</span></p></li><li class="md-list-item" cid="n36" mdtype="list_item"><p cid="n37" mdtype="paragraph" contenteditable="true" class="md-end-block md-p"><span md-inline="plain" class="md-plain">深拷贝方法：</span><span md-inline="softbreak" class="md-softbreak">
</span><span md-inline="plain" class="md-plain">\1. 使用</span><span md-inline="code" spellcheck="false" class="md-pair-s"><span class="md-meta md-before">`</span><code>JSON.parse(JSON.stringify(obj))</code><span class="md-meta md-after">`</span></span><span md-inline="plain" class="md-plain"> ，缺点：当对象有方法和undefined属性的时候会丢失</span><span md-inline="softbreak" class="md-softbreak">
</span><span md-inline="plain" class="md-plain">\2. 使用</span><span md-inline="code" spellcheck="false" class="md-pair-s"><span class="md-meta md-before">`</span><code>递归</code><span class="md-meta md-after"> `</span></span></p><ul class="ul-list" cid="n38" mdtype="list" data-mark="-"><li class="md-list-item" cid="n39" mdtype="list_item"><p cid="n40" mdtype="paragraph" contenteditable="true" class="md-end-block md-p"><span md-inline="plain" class="md-plain">如果存在</span><span md-inline="code" spellcheck="false" class="md-pair-s"><span class="md-meta md-before">`</span><code>循环引用</code><span class="md-meta md-after">`</span></span><span md-inline="plain" class="md-plain">就会出现</span><span md-inline="code" spellcheck="false" class="md-pair-s"><span class="md-meta md-before">`</span><code>堆栈溢出</code><span class="md-meta md-after">`</span></span></p></li><li class="md-list-item" cid="n41" mdtype="list_item"><p cid="n42" mdtype="paragraph" contenteditable="true" class="md-end-block md-p"><span md-inline="plain" class="md-plain">解决思路：把处理好的对象存起来，在处理新的对象的时候，会现在这个存的地方找一找有没有处理好，如果有就直接返回就行了</span></p></li></ul></li></ul><pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="false" lang="js" cid="n43" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="js"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 9.52344px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; min-height: 507px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><span><span>​</span>x</span></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor" style="left: 4px; top: 0px; height: 23.0469px;">&nbsp;</div></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">let</span> <span class="cm-def">obj</span> <span class="cm-operator">=</span> {</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-property">name</span>: <span class="cm-string">"zs"</span>,</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-property">age</span>: <span class="cm-number">20</span>,</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-property">father</span>: [<span class="cm-number">2</span>, <span class="cm-number">3</span>, <span class="cm-number">4</span>],</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;  };</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="" cm-zwsp="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;<span class="cm-keyword">function</span> <span class="cm-def">deepClone</span>(<span class="cm-def">target</span>) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-comment">//这一行如果不用三元判断 如果是数组会有bug会被拷贝成伪数组对象</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-keyword">let</span> <span class="cm-def">tempObj</span> <span class="cm-operator">=</span> <span class="cm-variable">Array</span>.<span class="cm-property">isArray</span>(<span class="cm-variable-2">target</span>) <span class="cm-operator">?</span> [] : {};</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> <span class="cm-def">key</span> <span class="cm-keyword">in</span> <span class="cm-variable-2">target</span>) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-keyword">if</span> (<span class="cm-keyword">typeof</span> <span class="cm-variable-2">target</span>[<span class="cm-variable-2">key</span>] <span class="cm-operator">===</span> <span class="cm-string">"object"</span>) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-variable-2">tempObj</span>[<span class="cm-variable-2">key</span>] <span class="cm-operator">=</span> <span class="cm-variable">deepClone</span>(<span class="cm-variable-2">target</span>[<span class="cm-variable-2">key</span>]);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;  } <span class="cm-keyword">else</span> {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-variable-2">tempObj</span>[<span class="cm-variable-2">key</span>] <span class="cm-operator">=</span> <span class="cm-variable-2">target</span>[<span class="cm-variable-2">key</span>];</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-keyword">return</span> <span class="cm-variable-2">tempObj</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="" cm-zwsp="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;<span class="cm-keyword">let</span> <span class="cm-def">obj1</span> <span class="cm-operator">=</span> <span class="cm-variable">deepClone</span>(<span class="cm-variable">obj</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">obj1</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">复制代码</span></span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 507px;"></div><div class="CodeMirror-gutters" style="display: none; height: 507px;"></div></div></div></pre><h3 cid="n44" mdtype="heading" contenteditable="true" class="md-end-block md-heading"><span md-inline="plain" class="md-plain">8. slice和splice的区别</span></h3><ul class="ul-list" cid="n45" mdtype="list" data-mark="-"><li class="md-list-item" cid="n46" mdtype="list_item"><p cid="n47" mdtype="paragraph" contenteditable="true" class="md-end-block md-p"><span md-inline="plain" class="md-plain">两者都是</span><span md-inline="code" spellcheck="false" class="md-pair-s"><span class="md-meta md-before">`</span><code>数组删除</code><span class="md-meta md-after">`</span></span><span md-inline="plain" class="md-plain">的方法</span></p></li></ul><p cid="n48" mdtype="paragraph" contenteditable="true" class="md-end-block md-p"><span md-inline="plain" class="md-plain">1.splice改变原数组，slice不改变原数组。</span><span md-inline="softbreak" class="md-softbreak">
</span><span md-inline="plain" class="md-plain"> 2.slice会返回一个新的数组，可以用于截取数组</span><span md-inline="softbreak" class="md-softbreak">
</span><span md-inline="plain" class="md-plain"> 3.splice除了可以删除之外，还可以替换，添加数组</span><span md-inline="softbreak" class="md-softbreak">
</span><span md-inline="plain" class="md-plain"> 4.splice可传入3个参数，slice接受2个参数</span></p><h3 cid="n49" mdtype="heading" contenteditable="true" class="md-end-block md-heading"><span md-inline="plain" class="md-plain">9. substr和substring的区别</span></h3><ul class="ul-list" cid="n50" mdtype="list" data-mark="-"><li class="md-list-item" cid="n51" mdtype="list_item"><p cid="n52" mdtype="paragraph" contenteditable="true" class="md-end-block md-p"><span md-inline="plain" class="md-plain">两者的作用都是</span><span md-inline="code" spellcheck="false" class="md-pair-s"><span class="md-meta md-before">`</span><code>截取字符串</code><span class="md-meta md-after">`</span></span><span md-inline="plain" class="md-plain">的</span></p></li><li class="md-list-item" cid="n53" mdtype="list_item"><p cid="n54" mdtype="paragraph" contenteditable="true" class="md-end-block md-p"><span md-inline="plain" class="md-plain">substr是从起始索引号开始提取指定长度的字符串</span></p></li><li class="md-list-item" cid="n55" mdtype="list_item"><p cid="n56" mdtype="paragraph" contenteditable="true" class="md-end-block md-p"><span md-inline="plain" class="md-plain">substring是提取字符串中两个指定索引号之间的字符</span></p></li></ul><h3 cid="n57" mdtype="heading" contenteditable="true" class="md-end-block md-heading"><span md-inline="plain" class="md-plain">10.let const  var区别</span></h3><p cid="n58" mdtype="paragraph" contenteditable="true" class="md-end-block md-p"><span md-inline="plain" class="md-plain">let和const都是用来</span><span md-inline="code" spellcheck="false" class="md-pair-s"><span class="md-meta md-before">`</span><code>声明变量</code><span class="md-meta md-after">`</span></span><span md-inline="plain" class="md-plain">的，在ES5中我们可以使用var来进行变量声明 -使用let和const作用</span><span md-inline="softbreak" class="md-softbreak">
</span><span md-inline="plain" class="md-plain"> </span><span md-inline="escape"><span class="md-meta md-before">\</span>-</span><span md-inline="plain" class="md-plain"> 防止for循环中变量提升的经典场景</span><span md-inline="softbreak" class="md-softbreak">
</span><span md-inline="plain" class="md-plain"> </span><span md-inline="escape"><span class="md-meta md-before">\</span>-</span><span md-inline="plain" class="md-plain"> </span><span md-inline="code" spellcheck="false" class="md-pair-s"><span class="md-meta md-before">`</span><code>不污染全局变量</code><span class="md-meta md-after">`</span></span></p><p cid="n59" mdtype="paragraph" contenteditable="true" class="md-end-block md-p"><span md-inline="strong" class="md-pair-s "><span class="md-meta md-before">**</span><strong><span md-inline="plain" class="md-plain">var关键字声明变量</span></strong><span class="md-meta md-after">**</span></span><span md-inline="softbreak" class="md-softbreak">
</span><span md-inline="plain" class="md-plain"> 1.var关键字声明变量存在，</span><span md-inline="code" spellcheck="false" class="md-pair-s"><span class="md-meta md-before">`</span><code>变量提升</code><span class="md-meta md-after">`</span></span><span md-inline="plain" class="md-plain">的问题；</span><span md-inline="softbreak" class="md-softbreak">
</span><span md-inline="plain" class="md-plain"> 2.var声明的变量不存在</span><span md-inline="code" spellcheck="false" class="md-pair-s"><span class="md-meta md-before">`</span><code>块级作用域</code><span class="md-meta md-after">`</span></span><span md-inline="plain" class="md-plain">，如果是全局变量在任何地方都可以调用；</span><span md-inline="softbreak" class="md-softbreak">
</span><span md-inline="plain" class="md-plain"> 3.var声明变量如果名称重复了，后面声明的会将前面声明的覆盖掉；</span></p><p cid="n60" mdtype="paragraph" contenteditable="true" class="md-end-block md-p"><span md-inline="strong" class="md-pair-s "><span class="md-meta md-before">**</span><strong><span md-inline="plain" class="md-plain">let关键子声明变量</span></strong><span class="md-meta md-after">**</span></span><span md-inline="softbreak" class="md-softbreak">
</span><span md-inline="plain" class="md-plain"> 1.</span><span md-inline="code" spellcheck="false" class="md-pair-s"><span class="md-meta md-before">`</span><code>不存在变量提升</code><span class="md-meta md-after">`</span></span><span md-inline="plain" class="md-plain">，let声明变量不存在变量提升的问题：如果在let声明变量前调用该变量就会报错（提示初始化前无法访问该变量）；</span><span md-inline="softbreak" class="md-softbreak">
</span><span md-inline="plain" class="md-plain"> 2.</span><span md-inline="code" spellcheck="false" class="md-pair-s"><span class="md-meta md-before">`</span><code>块级作用域</code><span class="md-meta md-after">`</span></span><span md-inline="plain" class="md-plain">，let声明变量存在块级作用域（全局、函数、eval严格模式），只在当前的代码块中生效，如果在当前代码块以外调用就会报错（当前的变量没有定义）；</span><span md-inline="softbreak" class="md-softbreak">
</span><span md-inline="plain" class="md-plain"> 3.</span><span md-inline="code" spellcheck="false" class="md-pair-s"><span class="md-meta md-before">`</span><code>不影响作用域链的操作</code><span class="md-meta md-after">`</span></span><span md-inline="softbreak" class="md-softbreak">
</span><span md-inline="plain" class="md-plain"> 4.</span><span md-inline="code" spellcheck="false" class="md-pair-s"><span class="md-meta md-before">`</span><code>不允许变量重复声明</code><span class="md-meta md-after">`</span></span><span md-inline="plain" class="md-plain">，let声明的变量是不允许重复声明的，如果同一个名称被重复声明了就会报错（当前的标识已经被声明了）；</span></p><p cid="n61" mdtype="paragraph" contenteditable="true" class="md-end-block md-p"><span md-inline="strong" class="md-pair-s "><span class="md-meta md-before">**</span><strong><span md-inline="plain" class="md-plain">const声明变量</span></strong><span class="md-meta md-after">**</span></span><span md-inline="softbreak" class="md-softbreak">
</span><span md-inline="plain" class="md-plain"> 1.const声明的变量也具有：</span><span md-inline="code" spellcheck="false" class="md-pair-s"><span class="md-meta md-before">`</span><code>不存在变量提升</code><span class="md-meta md-after">`</span></span><span md-inline="plain" class="md-plain">、</span><span md-inline="code" spellcheck="false" class="md-pair-s"><span class="md-meta md-before">`</span><code>块级作用域</code><span class="md-meta md-after">`</span></span><span md-inline="plain" class="md-plain">、</span><span md-inline="code" spellcheck="false" class="md-pair-s"><span class="md-meta md-before">`</span><code>不允许重复声明</code><span class="md-meta md-after">`</span></span><span md-inline="plain" class="md-plain">的特点；</span><span md-inline="softbreak" class="md-softbreak">
</span><span md-inline="plain" class="md-plain"> 2.const声明的变量都是</span><span md-inline="code" spellcheck="false" class="md-pair-s"><span class="md-meta md-before">`</span><code>常量</code><span class="md-meta md-after">`</span></span><span md-inline="plain" class="md-plain">（不允许改变的量），一旦声明就不允许被修改，如果修改就会报错--常数变量赋值</span><span md-inline="softbreak" class="md-softbreak">
</span><span md-inline="plain" class="md-plain"> 3.一般第三方的框架中会大量使用const声明变量，这样可以避免用户修改框架中的变量；</span><span md-inline="softbreak" class="md-softbreak">
</span><span md-inline="plain" class="md-plain"> 4.const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个</span><span md-inline="code" spellcheck="false" class="md-pair-s"><span class="md-meta md-before">`</span><code>内存地址</code><span class="md-meta md-after">`</span></span><span md-inline="plain" class="md-plain">，因此等同于常量。</span></p><h3 cid="n62" mdtype="heading" contenteditable="true" class="md-end-block md-heading"><span md-inline="plain" class="md-plain">11.new的过程</span></h3><ol class="ol-list" start="" cid="n63" mdtype="list"><li class="md-list-item" cid="n64" mdtype="list_item"><p cid="n65" mdtype="paragraph" contenteditable="true" class="md-end-block md-p"><span md-inline="plain" class="md-plain">创建一个新的空对象。（即实例对象）</span></p></li><li class="md-list-item" cid="n66" mdtype="list_item"><p cid="n67" mdtype="paragraph" contenteditable="true" class="md-end-block md-p"><span md-inline="plain" class="md-plain">让this指向这个新对象</span></p></li><li class="md-list-item" cid="n68" mdtype="list_item"><p cid="n69" mdtype="paragraph" contenteditable="true" class="md-end-block md-p"><span md-inline="plain" class="md-plain">执行构造函数里面的代码，给这个新对象添加属性和方法</span></p></li><li class="md-list-item" cid="n70" mdtype="list_item"><p cid="n71" mdtype="paragraph" contenteditable="true" class="md-end-block md-p"><span md-inline="plain" class="md-plain">返回这个新对象obj。（定义的构造函数中不写返回值。）</span></p></li></ol><h3 cid="n72" mdtype="heading" contenteditable="true" class="md-end-block md-heading"><span md-inline="plain" class="md-plain">12.防抖节流</span></h3><p cid="n73" mdtype="paragraph" contenteditable="true" class="md-end-block md-p"><span md-inline="strong" class="md-pair-s "><span class="md-meta md-before">**</span><strong><span md-inline="plain" class="md-plain">防抖</span></strong><span class="md-meta md-after">**</span></span></p><ul class="ul-list" cid="n74" mdtype="list" data-mark="-"><li class="md-list-item" cid="n75" mdtype="list_item"><p cid="n76" mdtype="paragraph" contenteditable="true" class="md-end-block md-p"><span md-inline="plain" class="md-plain">防抖是指在事件触发n秒后再执行，如果在n秒内再次被触发，则重新计算时间。（就是在触发某个事件后，在下一次触发之前，中间的间隔时间如果超过设置的时间才会发送请求，一直触发就不会发送请求 应用场景：</span><span md-inline="softbreak" class="md-softbreak">
</span><span md-inline="plain" class="md-plain">a、scroll事件滚动触发，</span><span md-inline="softbreak" class="md-softbreak">
</span><span md-inline="plain" class="md-plain">b、搜索框输入查询</span><span md-inline="softbreak" class="md-softbreak">
</span><span md-inline="plain" class="md-plain">c、表单验证</span><span md-inline="softbreak" class="md-softbreak">
</span><span md-inline="plain" class="md-plain">d、按钮提交事件</span><span md-inline="softbreak" class="md-softbreak">
</span><span md-inline="plain" class="md-plain">e、浏览器窗口缩放，resize事件</span></p></li></ul><pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="false" lang="js" cid="n77" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="js"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 9.52344px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; min-height: 254px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor" style="left: 4px; top: 0px; height: 23.0469px;">&nbsp;</div></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">function</span> <span class="cm-def">debounce</span>(<span class="cm-def">func</span>, <span class="cm-def">delay</span>) {</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-keyword">let</span> <span class="cm-def">timer</span> <span class="cm-operator">=</span> <span class="cm-atom">null</span> <span class="cm-comment">// 计时器</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-keyword">return</span> <span class="cm-keyword">function</span> (<span class="cm-meta">...</span><span class="cm-def">args</span>) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-variable">clearTimeout</span>(<span class="cm-variable-2">timer</span>) <span class="cm-comment">// 清除上一次计时器</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-variable-2">timer</span> <span class="cm-operator">=</span> <span class="cm-variable">setTimeout</span>(() <span class="cm-operator">=&gt;</span> {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-comment">// 重新定时</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-variable-2">func</span>.<span class="cm-property">apply</span>(<span class="cm-keyword">this</span>, <span class="cm-variable-2">args</span>)</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;  }, <span class="cm-variable-2">delay</span>)</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">复制代码</span></span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 254px;"></div><div class="CodeMirror-gutters" style="display: none; height: 254px;"></div></div></div></pre><p cid="n78" mdtype="paragraph" contenteditable="true" class="md-end-block md-p"><span md-inline="strong" class="md-pair-s "><span class="md-meta md-before">**</span><strong><span md-inline="plain" class="md-plain">节流</span></strong><span class="md-meta md-after">**</span></span></p><ul class="ul-list" cid="n79" mdtype="list" data-mark="-"><li class="md-list-item" cid="n80" mdtype="list_item"><p cid="n81" mdtype="paragraph" contenteditable="true" class="md-end-block md-p"><span md-inline="plain" class="md-plain">节流是指如果持续触发某个事件，则每隔n秒执行一次。</span></p></li></ul><pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="false" lang="js" cid="n82" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="js"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 9.52344px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; min-height: 230px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor" style="left: 4px; top: 0px; height: 23.0469px;">&nbsp;</div></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">function</span> <span class="cm-def">throtte</span>(<span class="cm-def">func</span>, <span class="cm-def">time</span>) {</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-keyword">let</span> <span class="cm-def">timer</span> <span class="cm-operator">=</span> <span class="cm-atom">null</span> <span class="cm-comment">// 计时器</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-keyword">return</span> <span class="cm-keyword">function</span> (<span class="cm-meta">...</span><span class="cm-def">args</span>) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-keyword">if</span> (<span class="cm-variable-2">timer</span>) <span class="cm-keyword">return</span> <span class="cm-comment">// 无视，直接返回</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-variable-2">timer</span> <span class="cm-operator">=</span> <span class="cm-variable">setTimeout</span>(() <span class="cm-operator">=&gt;</span> {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-variable-2">func</span>.<span class="cm-property">apply</span>(<span class="cm-keyword">this</span>, <span class="cm-variable-2">args</span>)</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;  }, <span class="cm-variable-2">time</span>)</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">复制代码</span></span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 230px;"></div><div class="CodeMirror-gutters" style="display: none; height: 230px;"></div></div></div></pre><h3 cid="n83" mdtype="heading" contenteditable="true" class="md-end-block md-heading"><span md-inline="plain" class="md-plain">13.promise的3种状态</span></h3><p cid="n84" mdtype="paragraph" contenteditable="true" class="md-end-block md-p"><span md-inline="plain" class="md-plain">这点简单介绍概念，用法后面在详细介绍</span></p><p cid="n85" mdtype="paragraph" contenteditable="true" class="md-end-block md-p"><span md-inline="strong" class="md-pair-s "><span class="md-meta md-before">**</span><strong><span md-inline="plain" class="md-plain">1 . 初始态</span><span md-inline="code" spellcheck="false" class="md-pair-s"><span class="md-meta md-before">`</span><code>pending</code><span class="md-meta md-after">`</span></span></strong><span class="md-meta md-after">**</span></span><span md-inline="softbreak" class="md-softbreak">
</span><span md-inline="plain" class="md-plain"> </span><span md-inline="escape"><span class="md-meta md-before">\</span>-</span><span md-inline="plain" class="md-plain"> pending。它的意思是 "待定的，将发生的"，相当于是一个初始状态。创建[Promise]对象时，且没有调用resolve或者是reject方法，相当于是初始状态。这个初始状态会随着你调用resolve，或者是reject函数而切换到另一种状态。</span><span md-inline="softbreak" class="md-softbreak">
</span><span md-inline="plain" class="md-plain"> </span><span md-inline="strong" class="md-pair-s "><span class="md-meta md-before">**</span><strong><span md-inline="plain" class="md-plain">2 . 成功态</span><span md-inline="code" spellcheck="false" class="md-pair-s"><span class="md-meta md-before">`</span><code>resolved--</code><span class="md-meta md-after">`</span></span><span md-inline="plain" class="md-plain">也叫</span><span md-inline="code" spellcheck="false" class="md-pair-s"><span class="md-meta md-before">`</span><code>fulfilled</code><span class="md-meta md-after">`</span></span></strong><span class="md-meta md-after">**</span></span><span md-inline="softbreak" class="md-softbreak">
</span><span md-inline="plain" class="md-plain"> </span><span md-inline="escape"><span class="md-meta md-before">\</span>-</span><span md-inline="plain" class="md-plain"> resolved。表示解决了，就是说这个承诺实现了。 要实现从pending到resolved的转变，需要在 创建Promise对象时，在函数体中调用了resolve方法(即第一个参数)。</span><span md-inline="softbreak" class="md-softbreak">
</span><span md-inline="plain" class="md-plain"> </span><span md-inline="strong" class="md-pair-s "><span class="md-meta md-before">**</span><strong><span md-inline="plain" class="md-plain">3 . 失败态</span><span md-inline="code" spellcheck="false" class="md-pair-s"><span class="md-meta md-before">`</span><code>rejected</code><span class="md-meta md-after">`</span></span></strong><span class="md-meta md-after">**</span></span><span md-inline="softbreak" class="md-softbreak">
</span><span md-inline="plain" class="md-plain"> </span><span md-inline="escape"><span class="md-meta md-before">\</span>-</span><span md-inline="plain" class="md-plain"> rejected。拒绝，失败。表示这个承诺没有做到，失败了。要实现从pending到rejected的转换，只需要在创建Promise对象时，调用reject函数。</span></p><h3 cid="n86" mdtype="heading" contenteditable="true" class="md-end-block md-heading"><span md-inline="plain" class="md-plain">14.冒泡排序</span></h3><pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="false" lang="js" cid="n87" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="js"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 9.52344px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; min-height: 300px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor" style="left: 4px; top: 0px; height: 23.0469px;">&nbsp;</div></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-comment">// 上口诀 双层for循环 外层长度-1 内层长度-1-i</span></span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;<span class="cm-keyword">let</span> <span class="cm-def">arr</span> <span class="cm-operator">=</span> [<span class="cm-number">4</span>, <span class="cm-number">3</span>, <span class="cm-number">1</span>, <span class="cm-number">7</span>, <span class="cm-number">8</span>, <span class="cm-number">10</span>]</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;<span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> <span class="cm-def">i</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>; <span class="cm-variable-2">i</span> <span class="cm-operator">&lt;</span> <span class="cm-variable">arr</span>.<span class="cm-property">length</span> <span class="cm-operator">-</span> <span class="cm-number">1</span>; <span class="cm-variable-2">i</span><span class="cm-operator">++</span>) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> <span class="cm-def">j</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>; <span class="cm-variable-2">j</span> <span class="cm-operator">&lt;</span> <span class="cm-variable">arr</span>.<span class="cm-property">length</span> <span class="cm-operator">-</span> <span class="cm-number">1</span> <span class="cm-operator">-</span> <span class="cm-variable-2">i</span>; <span class="cm-variable-2">j</span><span class="cm-operator">++</span>) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-keyword">if</span> (<span class="cm-variable">arr</span>[<span class="cm-variable-2">j</span>] <span class="cm-operator">&gt;</span> <span class="cm-variable">arr</span>[<span class="cm-variable-2">j</span> <span class="cm-operator">+</span> <span class="cm-number">1</span>]) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-keyword">let</span> <span class="cm-def">temp</span> <span class="cm-operator">=</span> <span class="cm-variable">arr</span>[<span class="cm-variable-2">j</span>]</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-variable">arr</span>[<span class="cm-variable-2">j</span>] <span class="cm-operator">=</span> <span class="cm-variable">arr</span>[<span class="cm-variable-2">j</span> <span class="cm-operator">+</span> <span class="cm-number">1</span>]</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-variable">arr</span>[<span class="cm-variable-2">j</span> <span class="cm-operator">+</span> <span class="cm-number">1</span>] <span class="cm-operator">=</span> <span class="cm-variable-2">temp</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">arr</span>)</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">复制代码</span></span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 300px;"></div><div class="CodeMirror-gutters" style="display: none; height: 300px;"></div></div></div></pre><h2 cid="n88" mdtype="heading" contenteditable="true" class="md-end-block md-heading"><span md-inline="plain" class="md-plain">Vue部分</span></h2><h3 cid="n89" mdtype="heading" contenteditable="true" class="md-end-block md-heading"><span md-inline="plain" class="md-plain">1.MVVM</span></h3><p cid="n90" mdtype="paragraph" contenteditable="true" class="md-end-block md-p"><span md-inline="code" spellcheck="false" class="md-pair-s"><span class="md-meta md-before">`</span><code>MVVM</code><span class="md-meta md-after">`</span></span><span md-inline="plain" class="md-plain">是三个单词的缩写，</span><span md-inline="code" spellcheck="false" class="md-pair-s"><span class="md-meta md-before">`</span><code>model</code><span class="md-meta md-after">`</span></span><span md-inline="plain" class="md-plain">(数据，一般来自ajax或本地存储)+</span><span md-inline="code" spellcheck="false" class="md-pair-s"><span class="md-meta md-before">`</span><code>view</code><span class="md-meta md-after">`</span></span><span md-inline="plain" class="md-plain">(视图template)+viewmodel(vue实例)</span></p><ul class="ul-list" cid="n91" mdtype="list" data-mark="-"><li class="md-list-item" cid="n92" mdtype="list_item"><p cid="n93" mdtype="paragraph" contenteditable="true" class="md-end-block md-p"><span md-inline="plain" class="md-plain">model数据变了，视图会跟着改变，如果用的是v-model，数据也会跟着改变，viewmodel在中间起一个桥梁作用</span></p></li><li class="md-list-item" cid="n94" mdtype="list_item" style=""><p cid="n95" mdtype="paragraph" contenteditable="true" class="md-end-block md-p"><span md-inline="plain" class="md-plain">model 和 view 就像现实中房东和租客一样，他们是不认识的，通过中介 viewmodel</span></p><pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="false" lang="" cid="n96" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang=""><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 9.52344px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; min-height: 23px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor" style="left: 4px; top: 0px; height: 23.0469px;">&nbsp;</div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">好处</span></pre></div></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 23px;"></div><div class="CodeMirror-gutters" style="display: none; height: 23px;"></div></div></div></pre><p cid="n97" mdtype="paragraph" contenteditable="true" class="md-end-block md-p"><span md-inline="plain" class="md-plain">：</span></p><ul class="ul-list" cid="n98" mdtype="list" data-mark="-"><li class="md-list-item" cid="n99" mdtype="list_item"><p cid="n100" mdtype="paragraph" contenteditable="true" class="md-end-block md-p"><span md-inline="plain" class="md-plain">数据驱动</span></p><ul class="ul-list" cid="n101" mdtype="list" data-mark="-"><li class="md-list-item" cid="n102" mdtype="list_item"><p cid="n103" mdtype="paragraph" contenteditable="true" class="md-end-block md-p"><span md-inline="plain" class="md-plain">因为数据变了。视图也会跟着变，所以在 vue 中不用操作dom来改变视图</span></p></li></ul></li><li class="md-list-item" cid="n104" mdtype="list_item" style=""><p cid="n105" mdtype="paragraph" contenteditable="true" class="md-end-block md-p"><span md-inline="plain" class="md-plain">解耦(</span></p><pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="false" lang="" cid="n106" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang=""><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 9.52344px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; min-height: 23px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor" style="left: 4px; top: 0px; height: 23.0469px;">&nbsp;</div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">降低了耦合性</span></pre></div></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 23px;"></div><div class="CodeMirror-gutters" style="display: none; height: 23px;"></div></div></div></pre><p cid="n107" mdtype="paragraph" contenteditable="true" class="md-end-block md-p"><span md-inline="plain" class="md-plain">)</span></p><ul class="ul-list" cid="n108" mdtype="list" data-mark="-"><li class="md-list-item" cid="n109" mdtype="list_item"><p cid="n110" mdtype="paragraph" contenteditable="true" class="md-end-block md-p"><span md-inline="plain" class="md-plain">由于 model 和 view 是没有关系的，是通过 viewmodel 结合在一起的，所以维护起来很方便，因为 model 逻辑代买改了，view 不用改</span></p></li></ul></li></ul></li></ul><h3 cid="n111" mdtype="heading" contenteditable="true" class="md-end-block md-heading"><span md-inline="plain" class="md-plain">2.vue生命周期</span></h3><ul class="ul-list" cid="n112" mdtype="list" data-mark="-"><li class="md-list-item" cid="n113" mdtype="list_item"><p cid="n114" mdtype="paragraph" contenteditable="true" class="md-end-block md-p"><span md-inline="plain" class="md-plain">vue中的生命周期是指组件从创建到销毁的过程,主要分为4个周期8个钩子函数</span></p></li></ul><p cid="n115" mdtype="paragraph" contenteditable="true" class="md-end-block md-p"><span md-inline="plain" class="md-plain">1.分别是创建阶段的</span><span md-inline="code" spellcheck="false" class="md-pair-s"><span class="md-meta md-before">`</span><code>beforeCreate</code><span class="md-meta md-after">`</span></span><span md-inline="plain" class="md-plain">，</span><span md-inline="code" spellcheck="false" class="md-pair-s"><span class="md-meta md-before">`</span><code>created</code><span class="md-meta md-after">`</span></span><span md-inline="plain" class="md-plain">，一般在beforeCreate写loading加载效果，使用户体验更好，一般在created中发送ajax请求获取数据</span></p><p cid="n116" mdtype="paragraph" contenteditable="true" class="md-end-block md-p"><span md-inline="plain" class="md-plain">2.然后是挂载阶段的</span><span md-inline="code" spellcheck="false" class="md-pair-s"><span class="md-meta md-before">`</span><code>beforeMount</code><span class="md-meta md-after">`</span></span><span md-inline="plain" class="md-plain">，</span><span md-inline="code" spellcheck="false" class="md-pair-s"><span class="md-meta md-before">`</span><code>mounted</code><span class="md-meta md-after">`</span></span><span md-inline="plain" class="md-plain">，一般会在mounted中操作DOM元素</span></p><p cid="n117" mdtype="paragraph" contenteditable="true" class="md-end-block md-p"><span md-inline="plain" class="md-plain">3.更新阶段的是</span><span md-inline="code" spellcheck="false" class="md-pair-s"><span class="md-meta md-before">`</span><code>beforeUpdate</code><span class="md-meta md-after">`</span></span><span md-inline="plain" class="md-plain"> ，</span><span md-inline="code" spellcheck="false" class="md-pair-s"><span class="md-meta md-before">`</span><code>updated</code><span class="md-meta md-after">`</span></span><span md-inline="plain" class="md-plain">，当数据更新时需要做统一的业务处理时，拿到最新的dom，可以使用updated 这个钩子函数</span></p><p cid="n118" mdtype="paragraph" contenteditable="true" class="md-end-block md-p"><span md-inline="plain" class="md-plain">4.最后是销毁阶段的</span><span md-inline="code" spellcheck="false" class="md-pair-s"><span class="md-meta md-before">`</span><code>beforeDestroy</code><span class="md-meta md-after">`</span></span><span md-inline="plain" class="md-plain">，</span><span md-inline="code" spellcheck="false" class="md-pair-s"><span class="md-meta md-before">`</span><code>destroyed</code><span class="md-meta md-after">`</span></span><span md-inline="plain" class="md-plain">，可以在beforeDestroy做一些清理的工作，比如说定时器 和解绑一些addEventListener监听的事件</span></p><ul class="ul-list" cid="n119" mdtype="list" data-mark="-"><li class="md-list-item" cid="n120" mdtype="list_item"><p cid="n121" mdtype="paragraph" contenteditable="true" class="md-end-block md-p"><span md-inline="plain" class="md-plain">补充：（还有</span><span md-inline="code" spellcheck="false" class="md-pair-s"><span class="md-meta md-before">`</span><code>keep-alive</code><span class="md-meta md-after">`</span></span><span md-inline="plain" class="md-plain">的两个钩子函数，使用场景是当组件切换时会进行销毁，因此组件中的初始化的4个钩子函数会多次执行，比较浪费资源,此时可以使用keep-alive纪行组件的缓存,可以让组件切换时不被销毁,keep-alive有两个独有的钩子函数,分别是</span><span md-inline="code" spellcheck="false" class="md-pair-s"><span class="md-meta md-before">`</span><code>activated</code><span class="md-meta md-after">`</span></span><span md-inline="plain" class="md-plain">和</span><span md-inline="code" spellcheck="false" class="md-pair-s"><span class="md-meta md-before">`</span><code>deactivated</code><span class="md-meta md-after">`</span></span><span md-inline="plain" class="md-plain">,是组件激活和失活时会执行的两个钩子函数）</span></p></li></ul><h3 cid="n122" mdtype="heading" contenteditable="true" class="md-end-block md-heading"><span md-inline="plain" class="md-plain">3.单向数据流</span></h3><p cid="n123" mdtype="paragraph" contenteditable="true" class="md-end-block md-p"><span md-inline="plain" class="md-plain">单向数据流是指父组件向子组件传递数据，子组件通过</span><span md-inline="code" spellcheck="false" class="md-pair-s"><span class="md-meta md-before">`</span><code>props</code><span class="md-meta md-after">`</span></span><span md-inline="plain" class="md-plain">接收，当父组件中的值改变了，子组件中对应的数据也会改变，因为props是</span><span md-inline="code" spellcheck="false" class="md-pair-s"><span class="md-meta md-before">`</span><code>只读</code><span class="md-meta md-after">`</span></span><span md-inline="plain" class="md-plain">的，所以无法直接在子组件中对父组件传递过来的值进行修改，但是如果这个数据是一个引用数据类型，是可以直接在子组件中修改数据中的某个属性的，只要不改变这个数据的</span><span md-inline="code" spellcheck="false" class="md-pair-s"><span class="md-meta md-before">`</span><code>内存地址</code><span class="md-meta md-after">`</span></span><span md-inline="plain" class="md-plain">就可以</span></p><h3 cid="n124" mdtype="heading" contenteditable="true" class="md-end-block md-heading"><span md-inline="plain" class="md-plain">4.双向数据绑定</span></h3><ul class="ul-list" cid="n125" mdtype="list" data-mark="-"><li class="md-list-item" cid="n126" mdtype="list_item"><p cid="n127" mdtype="paragraph" contenteditable="true" class="md-end-block md-p"><span md-inline="plain" class="md-plain">数据 -&gt; 视图</span></p></li><li class="md-list-item" cid="n128" mdtype="list_item"><p cid="n129" mdtype="paragraph" contenteditable="true" class="md-end-block md-p"><span md-inline="plain" class="md-plain">视图 -&gt; 数据</span></p></li></ul><p cid="n130" mdtype="paragraph" contenteditable="true" class="md-end-block md-p"><span md-inline="plain" class="md-plain">vue中普通指令都可以实现数据变了，视图会跟着变，但是有一个特殊的指令叫</span><span md-inline="code" spellcheck="false" class="md-pair-s"><span class="md-meta md-before">`</span><code>v-model</code><span class="md-meta md-after">`</span></span><span md-inline="plain" class="md-plain">，它一般用于表单控件，它可以实现双向数据绑定，所谓的双向数据就是数据变了，视图就会跟着改变，反过来也是</span></p><h3 cid="n131" mdtype="heading" contenteditable="true" class="md-end-block md-heading"><span md-inline="plain" class="md-plain">5.v-model原理</span></h3><p cid="n132" mdtype="paragraph" contenteditable="true" class="md-end-block md-p"><span md-inline="code" spellcheck="false" class="md-pair-s"><span class="md-meta md-before">`</span><code>v-model</code><span class="md-meta md-after">`</span></span><span md-inline="plain" class="md-plain">一般配合</span><span md-inline="code" spellcheck="false" class="md-pair-s"><span class="md-meta md-before">`</span><code>input</code><span class="md-meta md-after">`</span></span><span md-inline="plain" class="md-plain">框使用，实现双向数据绑定的效果，它是</span><span md-inline="code" spellcheck="false" class="md-pair-s"><span class="md-meta md-before">`</span><code>v-bind</code><span class="md-meta md-after">`</span></span><span md-inline="plain" class="md-plain">和</span><span md-inline="code" spellcheck="false" class="md-pair-s"><span class="md-meta md-before">`</span><code>v-on</code><span class="md-meta md-after">`</span></span><span md-inline="plain" class="md-plain">的语法糖，原理是通过v-bind将数据绑定给input框，再通过</span><span md-inline="code" spellcheck="false" class="md-pair-s"><span class="md-meta md-before">`</span><code>v-on:input</code><span class="md-meta md-after">`</span></span><span md-inline="plain" class="md-plain">，在input中的值改变时，通过$event可以获取到事件源对象 再通过</span><span md-inline="code" spellcheck="false" class="md-pair-s"><span class="md-meta md-before">`</span><code>target.value</code><span class="md-meta md-after">`</span></span><span md-inline="plain" class="md-plain">获取到input中更新后的值 将这个值再赋值给绑定的数据即可</span></p><p cid="n133" mdtype="paragraph" contenteditable="true" class="md-end-block md-p"><span md-inline="image" data-src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e9cf0606d3e84612a529357688939177~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?" contenteditable="false" class="md-image md-img-loaded"><span class="md-meta md-before md-content" contenteditable="true"><span class="md-image-before-src ty-focusable">![3.png](</span><span class="md-image-src-span ty-focusable">https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e9cf0606d3e84612a529357688939177~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?</span><span class="md-image-after-src">)</span></span><img referrerpolicy="no-referrer" alt="3.png" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e9cf0606d3e84612a529357688939177~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?" onerror="onImageErrorFunc(event)" onload="onLoadedFuncForQuickAction(event)"></span></p><h3 cid="n134" mdtype="heading" contenteditable="true" class="md-end-block md-heading"><span md-inline="plain" class="md-plain">6.事件传参</span></h3><pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="false" lang="perl" cid="n135" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="perl"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 9.52344px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; min-height: 138px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor" style="left: 4px; top: 0px; height: 23.0469px;">&nbsp;</div></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">在<span class="cm-meta">vue</span>的组件使用自定义事件时，<span class="cm-variable">$event</span>代表子组件抛出的数据，当这个自定义事件触发一个方法时，</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">可以不传<span class="cm-variable">$event</span>而且可以在方法中进行接收，但是如果写的话就一定要写成<span class="cm-variable">$event</span>的形式，这是一个固定写法，</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">或者这个方法既要传参又要使用事件对象，这个时候<span class="cm-variable">$event</span>也是必须要写的</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-operator">-</span> <span class="cm-variable">@click</span><span class="cm-operator">=</span><span class="cm-string">'fn'</span> 在回调函数直接通过参数可以拿到事件对象</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-operator">-</span> <span class="cm-variable">@click</span><span class="cm-operator">=</span><span class="cm-string">'fn($event)'</span> 这个时候<span class="cm-variable">@event</span>是固定写法</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">复制代码</span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 138px;"></div><div class="CodeMirror-gutters" style="display: none; height: 138px;"></div></div></div></pre><h3 cid="n136" mdtype="heading" contenteditable="true" class="md-end-block md-heading"><span md-inline="plain" class="md-plain">7.父子组件的声明周期执行顺序</span></h3><p cid="n137" mdtype="paragraph" contenteditable="true" class="md-end-block md-p"><span md-inline="plain" class="md-plain">1.初始化阶段时，先执行父组件的</span><span md-inline="code" spellcheck="false" class="md-pair-s"><span class="md-meta md-before">`</span><code>beforeCreate</code><span class="md-meta md-after">`</span></span><span md-inline="plain" class="md-plain">、</span><span md-inline="code" spellcheck="false" class="md-pair-s"><span class="md-meta md-before">`</span><code>created</code><span class="md-meta md-after">`</span></span><span md-inline="plain" class="md-plain">、</span><span md-inline="code" spellcheck="false" class="md-pair-s"><span class="md-meta md-before">`</span><code>beforeMount</code><span class="md-meta md-after">`</span></span><span md-inline="plain" class="md-plain">三个钩子函数，然后执行子组件的</span><span md-inline="code" spellcheck="false" class="md-pair-s"><span class="md-meta md-before">`</span><code>beforeCreate</code><span class="md-meta md-after">`</span></span><span md-inline="plain" class="md-plain">、</span><span md-inline="code" spellcheck="false" class="md-pair-s"><span class="md-meta md-before">`</span><code>created</code><span class="md-meta md-after">`</span></span><span md-inline="plain" class="md-plain">、</span><span md-inline="code" spellcheck="false" class="md-pair-s"><span class="md-meta md-before">`</span><code>beforeMount</code><span class="md-meta md-after">`</span></span><span md-inline="plain" class="md-plain">、</span><span md-inline="code" spellcheck="false" class="md-pair-s"><span class="md-meta md-before">`</span><code>mounted</code><span class="md-meta md-after">`</span></span><span md-inline="plain" class="md-plain">四个钩子函数，最后执行父组件的mounted钩子函数</span></p><p cid="n138" mdtype="paragraph" contenteditable="true" class="md-end-block md-p"><span md-inline="plain" class="md-plain">2.更新阶段，先执行父组件的</span><span md-inline="code" spellcheck="false" class="md-pair-s"><span class="md-meta md-before">`</span><code>beforeUpdate</code><span class="md-meta md-after">`</span></span><span md-inline="plain" class="md-plain">，然后执行子组件的</span><span md-inline="code" spellcheck="false" class="md-pair-s"><span class="md-meta md-before">`</span><code>beforeUpdate</code><span class="md-meta md-after">`</span></span><span md-inline="plain" class="md-plain">，</span><span md-inline="code" spellcheck="false" class="md-pair-s"><span class="md-meta md-before">`</span><code>updated</code><span class="md-meta md-after">`</span></span><span md-inline="plain" class="md-plain">，最后执行父组件的updated</span></p><p cid="n139" mdtype="paragraph" contenteditable="true" class="md-end-block md-p"><span md-inline="plain" class="md-plain">3.销毁阶段，先执行父组件的</span><span md-inline="code" spellcheck="false" class="md-pair-s"><span class="md-meta md-before">`</span><code>beforeDestroy</code><span class="md-meta md-after">`</span></span><span md-inline="plain" class="md-plain">，然后执行子组件的</span><span md-inline="code" spellcheck="false" class="md-pair-s"><span class="md-meta md-before">`</span><code>eforeDestroy</code><span class="md-meta md-after">`</span></span><span md-inline="plain" class="md-plain">，</span><span md-inline="code" spellcheck="false" class="md-pair-s"><span class="md-meta md-before">`</span><code>destroyed</code><span class="md-meta md-after">`</span></span><span md-inline="plain" class="md-plain">，最后执行父组件的destroyed</span></p><h3 cid="n140" mdtype="heading" contenteditable="true" class="md-end-block md-heading"><span md-inline="plain" class="md-plain">8.v-if和v-show的区别</span></h3><p cid="n141" mdtype="paragraph" contenteditable="true" class="md-end-block md-p"><span md-inline="code" spellcheck="false" class="md-pair-s"><span class="md-meta md-before">`</span><code>v-if</code><span class="md-meta md-after">`</span></span><span md-inline="plain" class="md-plain">和</span><span md-inline="code" spellcheck="false" class="md-pair-s"><span class="md-meta md-before">`</span><code>v-show</code><span class="md-meta md-after">`</span></span><span md-inline="plain" class="md-plain">都可以控制标签，实现组件的显示与隐藏，不同点是v-show是通过</span><span md-inline="code" spellcheck="false" class="md-pair-s"><span class="md-meta md-before">`</span><code>display</code><span class="md-meta md-after">`</span></span><span md-inline="plain" class="md-plain">的block和</span><span md-inline="code" spellcheck="false" class="md-pair-s"><span class="md-meta md-before">`</span><code>none</code><span class="md-meta md-after">`</span></span><span md-inline="plain" class="md-plain">属性来控制的，当元素隐藏时，页面结构依然存在</span></p><ul class="ul-list" cid="n142" mdtype="list" data-mark="-"><li class="md-list-item" cid="n143" mdtype="list_item"><p cid="n144" mdtype="paragraph" contenteditable="true" class="md-end-block md-p"><span md-inline="plain" class="md-plain">v-if是通过将元素创建和销毁来控制显示与隐藏的，当v-if的条件为否时，会直接销毁该元素，当满足时会重新创建出来，有可能会影响页面的回流或重绘</span></p></li><li class="md-list-item" cid="n145" mdtype="list_item"><p cid="n146" mdtype="paragraph" contenteditable="true" class="md-end-block md-p"><span md-inline="plain" class="md-plain">如果该元素需要频繁切换时可以使用v-show，不需要频繁切换时可以使用v-if，</span><span md-inline="code" spellcheck="false" class="md-pair-s"><span class="md-meta md-before">`</span><code>提高性能</code><span class="md-meta md-after">`</span></span></p></li></ul><h3 cid="n147" mdtype="heading" contenteditable="true" class="md-end-block md-heading"><span md-inline="plain" class="md-plain">9.v-for和v-if为什么要避免一起使用</span></h3><ul class="ul-list" cid="n148" mdtype="list" data-mark="-"><li class="md-list-item" cid="n149" mdtype="list_item"><p cid="n150" mdtype="paragraph" contenteditable="true" class="md-end-block md-p"><span md-inline="plain" class="md-plain">因为v-for的优先级比v-if要高，两者同时作用于一个标签或组件时，v-for会优先执行，执行后再进行v-if的判断，但是不满足v-if的条件的时候是可以不执行v-for的，这时候就会造成资源浪费，性能比较差</span></p></li><li class="md-list-item" cid="n151" mdtype="list_item"><p cid="n152" mdtype="paragraph" contenteditable="true" class="md-end-block md-p"><span md-inline="plain" class="md-plain">解决办法是可以通过计算属性将满足v-if判断条件的数据筛选出来，再使用v-if直接渲染筛选后的数据，或者是当v-if不依赖v-for时，可以通过</span><span md-inline="code" spellcheck="false" class="md-pair-s"><span class="md-meta md-before">`</span><code>template</code><span class="md-meta md-after">`</span></span><span md-inline="plain" class="md-plain">将v-if写在循环的外部，这样当不满足v-if的判断条件时，就不会再执行v-for了，也可以将数据放在</span><span md-inline="code" spellcheck="false" class="md-pair-s"><span class="md-meta md-before">`</span><code>计算属性</code><span class="md-meta md-after">`</span></span><span md-inline="plain" class="md-plain">里面计算过滤出来的数据在交给v-for循环，代替v-if的作用，即可解决。</span></p></li></ul><p cid="n153" mdtype="paragraph" contenteditable="true" class="md-end-block md-p"><span md-inline="plain" class="md-plain">作者：搬砖小胡</span><span md-inline="softbreak" class="md-softbreak">
</span><span md-inline="plain" class="md-plain">链接：</span><span md-inline="url" class="md-link md-pair-s" spellcheck="false"><a href="https://juejin.cn/post/7124301388737150983">https://juejin.cn/post/7124301388737150983</a></span><span md-inline="softbreak" class="md-softbreak">
</span><span md-inline="plain" class="md-plain">来源：稀土掘金</span><span md-inline="softbreak" class="md-softbreak">
</span><span md-inline="plain" class="md-plain">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span></p>